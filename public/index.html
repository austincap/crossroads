<!DOCTYPE html>
<meta charset="utf-8"></meta>
<head>
<link rel="stylesheet" href="css/index.css"></link>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.slim.js"></script>
<script type="text/javascript" src="https://d3js.org/d3.v5.js"></script>

<title>Crossroads</title>
</head>
<body>

<h1>Crossroads</h1>

<div id="adjacentblocks">

<div id="d3frame">
	<svg width="1000" height="700"></svg>
</div>

<div id="previewframe"></div>




<div id="submitnew">
<input type="text" id="nodename" value="node name"></input>
<input type="text" id="tag1" value="tag1"></input>
<input type="text" id="tag2" value="tag2"></input>
<input type="text" id="tag3" value="tag3"></input>
<button id="upload" onclick="sendNewPostToServer()">Upload</button>
</div>

</div>

<script>
	var socket = io();
	socket.emit('retrieveDatabase');




	var dbresults = {"nodes":[], "links":[]};

	function sendNewPostToServer(){
		socket.emit('sendNewPostToServer', {
			nodename: document.getElementById('nodename').value,
			tag1: document.getElementById('tag1').value,
			tag2: document.getElementById('tag2').value,
			tag3: document.getElementById('tag3').value
		});
	}


	function handleRetrievedDatabase(results){
		var k;
		var promise1 = new Promise(function(resolve, reject){
			for(i=0; i<results.length; i++){
						//console.log(results[i]);
						k = i+1;
						var foundPrev = false;
						var thisPostData = results[i]['post'];
						
						for(obj of Object.values(dbresults.nodes)){
							if(obj.id==thisPostData){
								foundPrev=true;
								thisPostData = obj.id;
								break;
							}
						}
						//console.log(dbresults.nodes.indexOf({id:results[i]['post']}));
						if(foundPrev==false){
							dbresults.nodes.push({id:results[i]['post'], group:7});
						}
						//if k is undefined, continue loop to prevent error from next expression
						if(results[k] == undefined){
							continue;
						}else{
							var thisNextPostData = results[k]['post'];
							for(obj of Object.values(dbresults.nodes)){
								if(obj.id==thisNextPostData){
									foundPrev=true;
									thisNextPostData = obj.id;
									break;
								}
							}

							// console.log(results[i]['tags'][0][0]);
							// 							console.log(results[i]['tags'][0]);

							// console.log(results[k]['tags'][0][0]);
							// console.log(results[i]['tags'][0][0]==results[k]['tags'][0][0]);
							if(results[i]['tags'][0][0]==results[k]['tags'][0][0]){
								dbresults.links.push({source:thisPostData, target:thisNextPostData, tag:results[i]['tags'][0]});
							}
						}




						// k = i+1;
						// dbresults.nodes.push({id:results[i]['post'], group:7});
						// for(tag of results[i]['tags']){
						// 	dbresults.nodes.push({id:tag[0], group:1});
						// 	dbresults.links.push({source:results[i]['post'], target:tag[0]});
						// }


						//if node doesn't exist in database, add it
						// if (dbresults.nodes.indexOf({id:results[i]['post']}) <= -1){
						// 	console.log(dbresults.nodes.indexOf({id:results[i]['post']}));
						// 	dbresults.nodes.push({id:results[i]['post']});
						// }
						//if k is undefined, continue loop to prevent error from next expression
						// if(results[k] == undefined){
						// 	continue;
						// }
						// if(results[i]['tagname']==results[k]['tagname']){
						// 	dbresults.links.push({source:results[i]['post'], target:results[k]['post']});
						// }
			}

			console.log("test");
			resolve(dbresults);
		});

		promise1.then(function(data){

			console.log(data);
			

			var svg = d3.select("svg")
			    .attr("width", 900)
			    .attr("height", 900)
			    .on("mousemove", mousemove);
   				//.on("mousedown", mousedownCanvas);

			var simulation = d3.forceSimulation()
				.force("collision", d3.forceCollide().radius(70))
			    .force("link", d3.forceLink().id(function(d) { return d.id; }))
			    .force("charge", d3.forceManyBody().strength(100).distanceMin(30))
			    .force("center", d3.forceCenter(900/2 , 900/2 ));


			// var link = svg.append("g")
			//     .attr("class", "links")
			//     .selectAll("line")
			//     .data(data.links)
			//     .enter()
			//     .append("line");

        // Draw lines for Links between Nodes
        var link = svg.selectAll(".gLink")
            .data(data.links)
          .enter().append("g")
            .attr("class", "gLink")
          .append("line")
            .attr("class", "links")
            .style("stroke", "#ccc")
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });


			var node = svg.append("g")
			    .attr("class", "nodes")
			    .selectAll("circle")
			    .data(data.nodes)
			    .enter()
			    .append("circle")
			      .attr("r", function(d){ return d.group;})
			      .on("mousedown", clickOnNode)
			      .call(d3.drag()
			          .on("start", dragstarted)
			          .on("drag", dragged)
			          .on("end", dragended));

			var myText = svg.selectAll(".mytext")
				.data(data.nodes)
				.enter()
				.append("text")
				.on("mousedown", clickOnNode);


			// node.append("title")
			//       .text(function(d) { console.log("PENIS"); return d.id; });

			myText.style("fill", "#0000ff")
				.attr("width", "10")
			    .attr("height", "10")
			    .text(function(d) { return d.id; });

			var cursor = svg.append("circle")
			    .attr("r", 30)
			    .attr("transform", "translate(-100,-100)")
			    .attr("class", "cursor");

			simulation
			    .nodes(data.nodes)
			    .on("tick", ticked);

			simulation.force("link")
			      .links(data.links);


			// var path = svg
			//     .append("g")
			//     .selectAll("path")
			//     .data(data.links)
			//     .enter()
			//     .append("path")
			//     .attr("class", function(d) { return "linkpath"; })
			//     .attr("id", function(d,i) { return "linkId_" + i; })
			//     .attr("marker-end", function(d) { return "url(#" + d.tag + ")"; });

		    // Append text to Link edges
	        var linkText = svg.selectAll(".gLink")
		        .data(data.links)
		        .append("text")
			    .attr("font-family", "Arial, Helvetica, sans-serif")
			    .attr("x", function(d) {
			        if (d.target.x > d.source.x) { return (d.source.x + (d.target.x - d.source.x)/2); }
			        else { return (d.target.x + (d.source.x - d.target.x)/2); }
			    })
		        .attr("y", function(d) {
			        if (d.target.y > d.source.y) { return (d.source.y + (d.target.y - d.source.y)/2); }
			        else { return (d.target.y + (d.source.y - d.target.y)/2); }
			    })
			    .attr("fill", "#333333")
		            .style("font", "normal 12px Arial")
		            .attr("dy", ".35em")
		            .text(function(d) { console.log(d);return d.tag; });

	
			function mousemove() {
			  cursor.attr("transform", "translate(" + String(d3.mouse(this)) + ")");
			}

			function ticked(){
			    link
			        .attr("x1", function(d) { return d.source.x; })
			        .attr("y1", function(d) { return d.source.y; })
			        .attr("x2", function(d) { return d.target.x; })
			        .attr("y2", function(d) { return d.target.y; });

			    node
			        .attr("cx", function(d) { return d.x; })
			        .attr("cy", function(d) { return d.y; });

			    myText.attr("x", function(d) { return d.x; })
        			.attr("y", function(d) { return d.y; });

			    linkText
				    .attr("x", function(d) {
				        if (d.target.x > d.source.x) { return (d.source.x + (d.target.x - d.source.x)/2); }
				        else { return (d.target.x + (d.source.x - d.target.x)/2); }
				    })
				    .attr("y", function(d) {
				        if (d.target.y > d.source.y) { return (d.source.y + (d.target.y - d.source.y)/2); }
				        else { return (d.target.y + (d.source.y - d.target.y)/2); }
				    });    			
			}



			function mousedownCanvas() {
			  var point = d3.mouse(this),
			      node = {x: point[0], y: point[1]},
			      n = data.nodes.push(node);

			  // add links to any nearby nodes
			  data.nodes.forEach(function(target) {
			    var x = target.x - node.x,
			        y = target.y - node.y;
			    if (Math.sqrt(x * x + y * y) < 30) {
			      data.links.push({source: node, target: target});
			    }
			  });

			  restart();
			}

			function mousedownNode(d, i) {
				//window.alert(d.id);
			  data.nodes.splice(i, 1);
			  data.links = data.links.filter(function(l) {
			    return l.source !== d && l.target !== d;
			  });
			  d3.event.stopPropagation();

			  restart();
			}


			function clickOnNode(d, i) {
				//window.alert(d.id);
			}


			function restart() {
			  node = node.data(data.nodes);

			  node.enter().insert("circle", ".cursor")
			      .attr("class", "node")
			      .attr("r", 5)
			      .on("mousedown", mousedownNode);

			  node.exit()
			      .remove();

			  link = link.data(data.links);

			  link.enter().insert("line", ".node")
			      .attr("class", "link");
			  link.exit()
			      .remove();
			  simulation
			      .nodes(data.nodes)
			      .on("tick", ticked);

			  simulation.force("link")
			      .links(data.links);
			}


			function dragstarted(d) {
			  if (!d3.event.active){ simulation.alphaTarget(0.3).restart();}
			  d.fx = d.x;
			  d.fy = d.y;
			}

			function dragged(d) {
			  d.fx = d3.event.x;
			  d.fy = d3.event.y;
			}

			function dragended(d) {
			  if (!d3.event.active){simulation.alphaTarget(0);}
			  d.fx = null;
			  d.fy = null;
			}

		});
	}

	socket.on('sendDatabase', function(results){
		handleRetrievedDatabase(results);
	});








</script>

</body>

</html>