<!DOCTYPE html>
<meta charset="utf-8"></meta>
<head>
<link rel="stylesheet" href="css/index.css"></link>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.slim.js"></script>
<script type="text/javascript" src="https://d3js.org/d3.v5.js"></script>

<title>Crossroads</title>
</head>
<body>

<h1>Crossroads</h1>

<div id="adjacentblocks">

<div id="d3frame">
	<svg width="1000" height="700"></svg>
</div>

<div id="previewframe"></div>

<div id="worldframe">
	<canvas id="worldcanvas"></canvas>
</div>



<div id="submitnew">
<input type="text" id="nodename" value="node name"></input>
<input type="text" id="tag1" value="tag1"></input>
<input type="text" id="tag2" value="tag2"></input>
<input type="text" id="tag3" value="tag3"></input>
<button id="upload" onclick="sendNewPostToServer()">Upload</button>
</div>

</div>

<script>
	var socket = io();
	socket.emit('retrieveDatabase');




	var canvas = document.getElementById('worldcanvas');
	var context = canvas.getContext('2d');
	var rect = {
		x:250,
		y:350,
		width:200,
		height:100
	};

	var dbresults = {"nodes":[], "links":[]};

	function sendNewPostToServer(){
		socket.emit('sendNewPostToServer', {
			nodename: document.getElementById('nodename').value,
			tag1: document.getElementById('tag1').value,
			tag2: document.getElementById('tag2').value,
			tag3: document.getElementById('tag3').value
		});
	}


	function handleRetrievedDatabase(results){
		var xpos = 345;
		var k;
		var promise1 = new Promise(function(resolve, reject){
			for(i=0; i<results.length; i++){
						context.beginPath();
						context.rect(xpos+i*xpos, 350, 200, 100);
						context.fillStyle = '#FFFFFF'; 
						context.fillStyle = 'rgba(225,225,225,0.5)';
						context.closePath();
						context.font = '40pt Kremlin Pro Web';
						context.fillStyle = '#000000';
						context.fillText(results[i]['post'], xpos+i*xpos, 415);
						//console.log(results[i]);
						k = i+1;
						dbresults.nodes.push({id:results[i]['post'], group:7});
						for(tag of results[i]['tags']){
							dbresults.nodes.push({id:tag[0], group:1});
							dbresults.links.push({source:results[i]['post'], target:tag[0]});
						}
						//if node doesn't exist in database, add it
						// if (dbresults.nodes.indexOf({id:results[i]['post']}) <= -1){
						// 	console.log(dbresults.nodes.indexOf({id:results[i]['post']}));
						// 	dbresults.nodes.push({id:results[i]['post']});
						// }
						//if k is undefined, continue loop to prevent error from next expression
						// if(results[k] == undefined){
						// 	continue;
						// }
						// if(results[i]['tagname']==results[k]['tagname']){
						// 	dbresults.links.push({source:results[i]['post'], target:results[k]['post']});
						// }
			}

			console.log("test");
			resolve(dbresults);
		});

		promise1.then(function(data){

			console.log(data);
			
			// var svg = d3.select("svg"),
			//     width = +svg.attr("width"),
			//     height = +svg.attr("height");



			var svg = d3.select("svg")
			    .attr("width", 900)
			    .attr("height", 900)
			    .on("mousemove", mousemove)
   				.on("mousedown", mousedownCanvas);

			var simulation = d3.forceSimulation()
				.force("collision", d3.forceCollide().radius(50))
			    .force("link", d3.forceLink().id(function(d) { return d.id; }))
			    .force("charge", d3.forceManyBody().strength(10).distanceMin(10))
			    .force("center", d3.forceCenter(900/2 , 900/2 ));


			  var link = svg.append("g")
			    .attr("class", "links")
			    .selectAll("line")
			    .data(data.links)
			    .enter().append("line");

			  var node = svg.append("g")
			    .attr("class", "nodes")
			    .selectAll("circle")
			    .data(data.nodes)
			    .enter().append("circle")
			      .attr("r", function(d){ return d.group;})
			      .on("mousedown", mousedownNode)
			      .call(d3.drag()
			          .on("start", dragstarted)
			          .on("drag", dragged)
			          .on("end", dragended));



			  var myText = svg.selectAll(".mytext")
						.data(data.nodes)
						.enter()
						.append("text")
						.on("mousedown", mousedownNode);

			  node.append("title")
			      .text(function(d) { return d.id; });

			  myText.style("fill", "#0000ff")
				 .attr("width", "10")
			     .attr("height", "10")
			     .text(function(d) { return d.id; });



				var cursor = svg.append("circle")
				    .attr("r", 30)
				    .attr("transform", "translate(-100,-100)")
				    .attr("class", "cursor");
				function mousemove() {
				  cursor.attr("transform", "translate(" + String(d3.mouse(this)) + ")");
				}

			  simulation
			      .nodes(data.nodes)
			      .on("tick", ticked);

			  simulation.force("link")
			      .links(data.links);

			  function ticked(){
			    link
			        .attr("x1", function(d) { return d.source.x; })
			        .attr("y1", function(d) { return d.source.y; })
			        .attr("x2", function(d) { return d.target.x; })
			        .attr("y2", function(d) { return d.target.y; });

			    node
			        .attr("cx", function(d) { return d.x; })
			        .attr("cy", function(d) { return d.y; });

			    myText.attr("x", function(d) { return d.x; })
        			.attr("y", function(d) { return d.y; });
			  }



			function mousedownCanvas() {
			  var point = d3.mouse(this),
			      node = {x: point[0], y: point[1]},
			      n = data.nodes.push(node);

			  // add links to any nearby nodes
			  data.nodes.forEach(function(target) {
			    var x = target.x - node.x,
			        y = target.y - node.y;
			    if (Math.sqrt(x * x + y * y) < 30) {
			      data.links.push({source: node, target: target});
			    }
			  });

			  restart();
			}

			function mousedownNode(d, i) {
				window.alert(d.id);
			  data.nodes.splice(i, 1);
			  data.links = data.links.filter(function(l) {
			    return l.source !== d && l.target !== d;
			  });
			  d3.event.stopPropagation();

			  restart();
			}


			function restart() {
			  node = node.data(data.nodes);

			  node.enter().insert("circle", ".cursor")
			      .attr("class", "node")
			      .attr("r", 5)
			      .on("mousedown", mousedownNode);

			  node.exit()
			      .remove();

			  link = link.data(data.links);

			  link.enter().insert("line", ".node")
			      .attr("class", "link");
			  link.exit()
			      .remove();
			  simulation
			      .nodes(data.nodes)
			      .on("tick", ticked);

			  simulation.force("link")
			      .links(data.links);
			}


			function dragstarted(d) {
			  if (!d3.event.active){ simulation.alphaTarget(0.3).restart();}
			  d.fx = d.x;
			  d.fy = d.y;
			}

			function dragged(d) {
			  d.fx = d3.event.x;
			  d.fy = d3.event.y;
			}

			function dragended(d) {
			  if (!d3.event.active){simulation.alphaTarget(0);}
			  d.fx = null;
			  d.fy = null;
			}

		});
	}

	socket.on('sendDatabase', function(results){
		handleRetrievedDatabase(results);
	});

	function getMousePos(canvas, event) {
		var rect = canvas.getBoundingClientRect();
		return {
			x: event.clientX - rect.left,
			y: event.clientY - rect.top
		};
	}
	function isInside(pos, rect){
		return pos.x > rect.x && pos.x < rect.x+rect.width && pos.y < rect.y+rect.height && pos.y > rect.y
	}



	function drawCircle(result){

	}
	context.beginPath();
	context.rect(250, 350, 200, 100); 
	context.fillStyle = '#FFFFFF'; 
	context.fillStyle = 'rgba(225,225,225,0.5)';
	context.fillRect(25,72,32,32);
	context.fill(); 
	context.lineWidth = 2;
	context.strokeStyle = '#000000'; 
	context.stroke();
	context.closePath();
	context.font = '40pt Kremlin Pro Web';
	context.fillStyle = '#000000';
	context.fillText('Start', 345, 415);


	canvas.addEventListener('click', function(evt) {
		var mousePos = getMousePos(canvas, evt);
	    //debugger;
		if (isInside(mousePos,rect)) {
			context.fillStyle = '#CEFCE3';
			alert('clicked inside rect');
	    }else{
	        alert('clicked outside rect');
	    }	
	}, false);






</script>

</body>

</html>