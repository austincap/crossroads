<!DOCTYPE html>
<meta charset="utf-8"></meta>
<head>
<link rel="stylesheet" href="css/index.css"></link>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script src="linkify.min.js"></script>
<script src="linkify-jquery.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.slim.js"></script>
<script type="text/javascript" src="https://d3js.org/d3.v5.js"></script>
<!-- <script src="linkify.js"></script>
<script src="linkify-html.js"></script> -->


<title>Crossroads</title>
</head>
<body>

<h1>Crossroads</h1>

<div id="adjacentblocks">

<div id="d3frame" min-width="1000px">
	<svg ></svg>
</div>

<div id="previewframe">
<button id="upvote">Love it</button>
<button id="downvote">Hate it</button>
<button id="tagIt">Tag it</button>
<button id="closeWindow" onclick="document.getElementById('previewframe').style.display='none';">Close</button>
<br/>
<hr/>
<div id="previewContent">test</div>
</div>

<div id="upvoteModal">
<div id="tagNameInModal"></div>
<button id="upvoteTag">Upvote tag?</button>
</div>




<div id="submitnew">
<input type="text" id="nodename" class="submissionslot" placeholder="post title goes here"></input>
<input type="text" id="userInputtedContent" class="submissionslot" placeholder="link goes here"></input>
<br/>
<input type="text" id="tag1" class="submissionslot" placeholder="tag1 (must fill!)"></input><br/>
<input type="text" id="tag2" placeholder="tag2"></input><br/>
<!-- <button id="addTagForUpload" onclick="showAdditionalTagInput()">Add Tag</button>
 --><button id="upload" onclick="sendNewPostToServer()" disabled="disabled">Upload</button>
</div>

</div>

<script>
	var socket = io();
	socket.emit('retrieveDatabase');
	var dbresults = {"nodes":[], "links":[]};

	linkifyOptions = {
	  attributes: null,
	  className: 'linkified',
	  defaultProtocol: 'http',
	  events: null,
	  format: function (value, type) {
	    return value;
	  },
	  formatHref: function (href, type) {
	    return href;
	  },
	  ignoreTags: [],
	  nl2br: false,
	  tagName: 'a',
	  target: {
	    url: '_blank'
	  },
	  validate: true
	};


	function sendNewPostToServer(){
		if(document.getElementById('tag2').value==""){
			socket.emit('sendNewPostToServer1', {
				nodename: document.getElementById('nodename').value,
				nodecontent: document.getElementById('userInputtedContent').value,
				tag1: document.getElementById('tag1').value.toLowerCase()
			});
		}else{
			socket.emit('sendNewPostToServer2', {
				nodename: document.getElementById('nodename').value,
				nodecontent: document.getElementById('userInputtedContent').value,
				tag1: document.getElementById('tag1').value.toLowerCase(),
				tag2: document.getElementById('tag2').value.toLowerCase()
			});			
		}
	}


	// function showAdditionalTagInput(){
	// 	if(window.getComputedStyle(document.getElementById("tag2")).display=="none"){
	// 		document.getElementById("tag2").style.display="block";
	// 	}else if(window.getComputedStyle(document.getElementById("tag3")).display=="none"){
	// 		document.getElementById("tag3").style.display="block";
	// 	}
	// }

	var inputs = $(".submissionslot");

	var validateInputs = function validateInputs(inputs) {
	  var validForm = true;
	  inputs.each(function(index) {
	    var input = $(this);
	    if (input.val()=="") {
	    	$("#upload").attr("disabled", "disabled");
	    	validForm = false;
	    }
	  });
	  return validForm;
	}


	inputs.change(function() {
	  if (validateInputs(inputs)) {
	    document.getElementById("upload").removeAttribute("disabled");
	  }
	});

	text_truncate = function(str, length, ending) {
	    if (length == null) {
	      length = 100;
	    }
	    if (ending == null) {
	      ending = '...';
	    }
	    if (str.length > length) {
	      return str.substring(0, length - ending.length) + ending;
	    } else {
	      return str;
	    }
	};

	var previewContent = document.getElementById("previewContent");

	function handleRetrievedDatabase(results){
		var k;
		var promise1 = new Promise(function(resolve, reject){
			for(i=0; i<results.length; i++){
						//console.log(results[i]);
						k = i+1;
						var foundPrev = false;
						var thisPostData = results[i]['post'];
						
						for(obj of Object.values(dbresults.nodes)){
							if(obj.id==thisPostData){
								foundPrev=true;
								thisPostData = obj.id;
								break;
							}
						}
						//console.log(dbresults.nodes.indexOf({id:results[i]['post']}));
						if(foundPrev==false){
							dbresults.nodes.push({id:results[i]['post'], upvotes:results[i]['upvotes'], content:results[i]['content']});
						}
						//if k is undefined, continue loop to prevent error from next expression
						if(results[k] == undefined){
							continue;
						}else{
							var thisNextPostData = results[k]['post'];
							for(obj of Object.values(dbresults.nodes)){
								if(obj.id==thisNextPostData){
									foundPrev=true;
									thisNextPostData = obj.id;
									break;
								}
							}
							if(results[i]['tags'][0][0]==results[k]['tags'][0][0]){
								dbresults.links.push({source:thisPostData, target:thisNextPostData, tag:results[i]['tags'][0]});
							}
						}
			}

			console.log("test");
			resolve(dbresults);
		});

		promise1.then(function(data){

			console.log(data);
			
			var svg = d3.select("svg")
			    .attr("width", 2000)
			    .attr("height", 2000)
			    .on("mousemove", mousemove);
   				//.on("mousedown", mousedownCanvas);

			var simulation = d3.forceSimulation()
				.force("collision", d3.forceCollide().radius(70))
			    .force("link", d3.forceLink().id(function(d) { return d.id; }))
			    .force("charge", d3.forceManyBody().strength(1000).distanceMin(30))
			    .force("center", d3.forceCenter(700 , 700));

			var node = svg.append("g")
			    .attr("class", "nodes")
			    .selectAll("circle")
			    .data(data.nodes)
			    .enter()
			    .append("circle")
			      .attr("r", function(d){ return 5*d.upvotes;})
			      .on("mousedown", clickOnNode)
			      .call(d3.drag()
			          .on("start", dragstarted)
			          .on("drag", dragged)
			          .on("end", dragended));

			var postTitle = svg.selectAll(".mytext")
				.data(data.nodes)
				.enter()
				.append("text")
				.on("mousedown", clickOnNode);

			postTitle.style("fill", "#0000ff")
				.attr("width", "10")
			    .attr("height", "10")
			    .text(function(d) { return text_truncate(d.id, 17); });

			var cursor = svg.append("circle")
			    .attr("r", 30)
			    .attr("transform", "translate(-100,-100)")
			    .attr("class", "cursor");

			simulation.nodes(data.nodes).on("tick", ticked);
			simulation.force("link").links(data.links);

			var path = svg.append("g")
			    .selectAll("path")
			    .data(data.links)
			    .enter()
			    .append("path")
			    .attr("class", "linkpath")
			    .attr("id", function(d,i) { return "linkId_" + i; })
			    .attr("marker-end", function(d) { return "url(#" + d.tag + ")"; });

		    var linktext = svg.append("g").selectAll(".gLink").data(data.links);
			     linktext.enter().append("g").attr("class", "gLink")
			     .append("text")
			     .attr("class", "gLink")
			     .style("font-size", "13px")
			     .attr("x", "50")
			     .attr("y", "-5")
			     .attr("text-anchor", "start")
			     .style("fill","#000")
			     .append("textPath")
			     .attr("xlink:href",function(d,i) { return "#linkId_" + i;})
			     .text(function(d) { 
			         return d.tag; //Can be dynamic via d object 
			     })
			     .on("mousedown", clickOnTag);

			function mousemove() {
			  cursor.attr("transform", "translate(" + String(d3.mouse(this)) + ")");
			}

			function ticked(){
			    node
			        .attr("cx", function(d) { return d.x; })
			        .attr("cy", function(d) { return d.y; });

				postTitle.attr("x", function(d) { return d.x; })
        			.attr("y", function(d) { return d.y; });			

				path.attr("d", function(d) {
				    var dx = d.target.x - d.source.x,
				        dy = d.target.y - d.source.y;
				    return "M " + d.source.x + " " + d.source.y + " L " + d.target.x + " " + d.target.y;
				});
			}

			function mousedownCanvas() {
			  var point = d3.mouse(this),
			      node = {x: point[0], y: point[1]},
			      n = data.nodes.push(node);

			  // add links to any nearby nodes
			  data.nodes.forEach(function(target) {
			    var x = target.x - node.x,
			        y = target.y - node.y;
			    if (Math.sqrt(x * x + y * y) < 30) {
			      data.links.push({source: node, target: target});
			    }
			  });

			  restart();
			}

			function mousedownNode(d, i) {
				//window.alert(d.id);
			  data.nodes.splice(i, 1);
			  data.links = data.links.filter(function(l) {
			    return l.source !== d && l.target !== d;
			  });
			  d3.event.stopPropagation();

			  restart();
			}

			function clickOnTag(d, i){
				console.log(d.tag);
				document.getElementById('tagNameInModal').innerHTML = d.tag;
				document.getElementById('upvoteModal').style.display = "block";

			}

			function clickOnNode(d, i){
				//previewFrame.innerHTML = linkifyHtml(d.content, linkifyOptions);
				//linkifyStr(previewFrame, linkifyOptions);
				previewContent.innerHTML = "<a href="+d.content+">"+d.content+"</a>";
				document.getElementById('previewframe').style.display = "block";
				//window.alert(d.content);
			}

			function restart() {
			  node = node.data(data.nodes);

			  node.enter().insert("circle", ".cursor")
			      .attr("class", "node")
			      .attr("r", 5)
			      .on("mousedown", mousedownNode);

			  node.exit()
			      .remove();

			  link = link.data(data.links);

			  link.enter().insert("line", ".node")
			      .attr("class", "link");
			  link.exit()
			      .remove();
			  simulation
			      .nodes(data.nodes)
			      .on("tick", ticked);

			  simulation.force("link")
			      .links(data.links);
			}

			function dragstarted(d) {
			  if (!d3.event.active){ simulation.alphaTarget(0.3).restart();}
			  d.fx = d.x;
			  d.fy = d.y;
			}

			function dragged(d) {
			  d.fx = d3.event.x;
			  d.fy = d3.event.y;
			}

			function dragended(d) {
			  if (!d3.event.active){simulation.alphaTarget(0);}
			  d.fx = null;
			  d.fy = null;
			}

		});
	}

	socket.on('sendDatabase', function(results){
		handleRetrievedDatabase(results);
	});


</script>

</body>

</html>